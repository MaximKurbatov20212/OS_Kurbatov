1) Про fork:

Системный вызов fork(2) создаёт новый процесс, исполняющий копию исходного процесса, который отличается от родительского 
значениями PID (идентификатор процесса) и PPID (идентификатор родительского процесса).
При успешном завершении родителю возвращается PID процесса-потомка, а процессу-потомку возвращается 0. 
При неудаче родительскому процессу возвращается -1, процесс-потомок не создается, а значение errno устанавливается должным образом. 
После возврата из fork(2), оба процесса продолжают исполнение с той точки, где fork(2) был вызван.

PID(process IP) - атрибут процесса, уникальный идентификатор, позволяющий ядру системы различать процессы. Одновременно 
не может быть два процесса, с одинаковым PID. Когда процесс завершает свою работу, ядро освобождает занятый им идентификатор.

PPID(Parent Process ID) - Идентификатор процесса, породившего данный процесс.
Например, в нашей программе дочерний процесс имеет PPID, равный PID родительского процесса. 
----------------------------------------------------------------------------------------------------------------------------------------

2) Про exec:
Процесс может заменить текущую программу на новую, исполнив системный вызов exec(2).
Этот вызов заменяет текст, данные, стек и остальные сегменты виртуального адресного
пространства текущей программы на соответствующие сегменты новой программы. Однако
пользовательская область при этом вызове сохраняется.

Функция execvp дублируют действия оболочки, относящиеся к поиску исполняемого файла, 
если указанное имя файла не содержит символ черты (/). Те мы можем команду cat, которая 
явлется исполняемым файлом, можем рапустить через этот системный вызов. 
Путь поиска определяется в окружении переменной PATH.
Если эта переменная не определена, то используется путь поиска ":/bin:/usr/bin" по умолчанию.(В моем случае /bin/cat)
-----------------------------------------------------------------------------------------------------------------------------------------
3) Про wait:
pid_t wait(int *status);

Функция wait приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не завершится, 
или до появления сигнала, который либо завершает текущий процесс, либо требует вызвать функцию-обработчик.

В перменную status сохраняют информацию о статусе дочернего процесса, но в данном задании это нам это не надо,
поэтому я передал, в качестве аргумента, NULL.
-----------------------------------------------------------------------------------------------------------------------------------------
4) Что если родительский процесс завершится раньше, чем дочерний?

Такой дочерний процесс станет так называемым демоном.

Демоны — это неинтерактивные процессы, которые запускаются обычным образом — путем загрузки в память соответствующих им программ
(исполняемых файлов), и выполняются в фоновом режиме. Обычно демоны запускаются при инициализации системы.
Демоны не связаны ни с одним пользовательским сеансом работы и не могут непосредственно управляться пользователем. 