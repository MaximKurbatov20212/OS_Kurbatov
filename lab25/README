Родительский процесс создает два подпроцесса, которые скопируют файловые дескрипторы. Каждый из процессов вначале 
закроет нужный конец трубы(написал в коде).
Далее через файловые дескипторы мы может осуществить обмен данными между процессами.
Родительский же процесс закроет оба конца канала(по заданию он не участвует в обмене сообщениями).
-----------------------------------------------------------------------------------------------------------------

pipe() создает программный канал.
Функция возвращает два файловых дескриптора в массиве fildes[]  причем
fildes[0] служит для чтения данных из канала, a fildes[1] — для записи
данных в канал.

Программный канал - механизм передачи данных от одного процесса - другому. Он представляет собой поток байтов, 
реализованный как кольцевой буфер. Программный канал имеет начало (исток) и ко­нец (приемник). В исток этого потока можно записывать данные,
а из приемни­ка — считывать. Исток за­полняет буфер, пока там есть место. Приемник считывает данные, пока буфер не опустеет.
-----------------------------------------------------------------------------------------------------------------

Про read:
ssize_t read(int fd, void *buf, size_t count)
read() считывает количество байтов count из файлового дескриптора fd в buf.
Не ошибка, если число байтов меньше, чем count, просто вернется меньше количество байт.

В случае успеха вернет количество считанных байтов(0 - индикатор конца файла)
В случае неудачи вернет -1 и errno будет установлена должным образом.
------------------------------------------------------------------------------------------------------------------

Про write:
ssize_t write(int fd, const void *buf, size_t count);
write() записывает count байтов из буфера, начиная с buf в файл, на который ссылается файловый дескриптор fd.
Опять же, не ошибка, если число байтов меньше, чем count, просто вернется меньше количество байт.

В случае успеха вернет количество записанных байтов
В случае неудачи вернет -1 и errno будет установлена должным образом.
-------------------------------------------------------------------------------------------------------------------

Про fgets:
char *fgets(char *s, int size, FILE *stream)
Считывает до size - 1(тк надо еще добавить /0) символов из потока stream и сохраняет их в s. 
В случае успеха возвращает указатель на считанную строку, те на s
В случае неудачи возвращает NULL(например файл не был открыт для чтения)

Про fork и wait рассказывал в 9 лабе