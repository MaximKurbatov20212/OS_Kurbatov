Вопрос: 
Что такое куча?
Ответ:
Куча - Часть памяти процесса, представляющая структуру данных, следящую за тем, какие блоки памяти из уже выделенных были освобождены.

Вопрос про malloc:
А если нет в куче подходящего свободного участка памяти, что тогда?
Нет ни слова как работает free.

Ответ:
Если в куче нет свободного участка памяти, то возвращается NULL.

Как работает free(address). Алгоритм парных меток. 

Каждый блок данных окружен двумя метками(заголовками), которые содержат размер блока, который они окружают.
 
1) Нам нужно посмотреть, свободен ли блок перед данным. Для этого нам нужно посмотреть его хедер, который мы можем вычислить как address - 2. (Размер хедера одно слово)
2) Если этот блок занят(размер отрицательный), то оставляем его в покое.
3) Если же свободен, то нам надо просто надо объединить два блока. Для этого нужно просто сложить значения размеров блоков в записать в хедер нового большого блока.
В нашем случае "Заголовок блока 1" и "Заголовок блока 2" будут заголовками нового большого блока.

Похожим образом присоединяется и сосед, стоящий после него. Единственное отличие состоит в том, что этого соседа все-таки нужно извлекать из списка свободных блоков.

+---------------------+
|  Заголовок блока 1  |
+---------------------+
|			          |
|			          |
|			          |
|			          |
|	Блок 1(свободен)  |
|			          |
|			          |
|			          |
+---------------------+ 
|  Заголовок блока 1  |	
+---------------------+
|  Заголовок блока 2  |
+---------------------+ <---- free(address)
|			          |
|			          |
|			          |
|   Блок 2            |
| (надо освободить)   |
|			          |
|			          |
|			          |
|			          |
+---------------------+
|  Заголовок блока 2  |
+---------------------+


Вопрос про хедеры:
Почему надо писать реализацию в каждый файл? почему не будет копирования? почему уменьшается время компиляции?
Плюс вы говорите про реализацию, но так ничего и не объяснили про назначение .h файлов.

Ответ:
Пусть есть множество функций, которые мы хотим использовать в других .с файлах.

1) Первый вариант, это просто написать все эти функции в каждый .c файл. Тогда при компиляции
мы все эти функции скомпилируем столько раз, сколько у нас .с файлов.

2) Второй вариант, это прописать их реализации в .h файл и подключить этот файл куда нам надо, но тогда вначале 
произойдет их подстановка, а потом мы опять их будем компилировать в каждом файле, куда мы этот .h файл подключили.

3) Третий вариант, прописать их реализации в functions.с файл. Создать functions.h файл c их обьявлениями и подключить его
во все .c файлы. Тогда, functions.c мы скомпилируем всего один раз и все остальные .с файлы смогут использовать эти функции.

Итог: .h файлы нужны для уменьшения времени компиляции.